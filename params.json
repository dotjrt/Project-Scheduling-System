{"name":"Optimizing Resource Allocation for Project Managers","tagline":"Better scheduling of resources to time-sensitive tasks within a project network","body":"The optimal allocation of resources to tasks requires a significant effort on the part of business managers across many industries. The undertaking can be time consuming, and in some cases, personnel are devoted solely to the job of scheduling resources to projects and tasks. Artificial intelligence could assist in the automation of this process and allow project managers to focus their efforts in other areas. \r\n\r\n## What\r\nMy project is a system that will optimize resource allocation to tasks within a task network. The system is given two inputs: A task network where some tasks may be dependent on the completion of others in order to be started and a resource pool where each resource's efficiency for each task is rated on a scale of 1-5, 5 being the best. \r\n\r\nThe system will then output a Gantt chart showing a schedule of when tasks should be started and completed, to include the possibility of \"float\" - that is, a possible delay in completing a task such that it will not hold up the rest of the project from on-time completion. The system will also output an optimized day-by-day assignment of resources to tasks. \r\n\r\n## Why\r\nThis software is intended to be a tool for project managers within a business organization to assist in the process of more efficient resource allocation within the confines of a complex project schedule. \r\n\r\n## Methods\r\nThe system takes two inputs provided by a project manager. Input consists of a project with a dependent task network like the one pictured below. The project manager also provides a resource pool where each resource (i.e. employee/engineer) has been rated on a scale of 1-5 for their ability to complete each task. \r\n\r\n![Project network](https://github.com/jrthom18/Project-Scheduling-System/blob/master/images/SampleTaskNetwork.PNG?raw=true)\r\n\r\n![Sample resource pool](https://github.com/jrthom18/Project-Scheduling-System/blob/master/images/ResourcePool.png?raw=true)\r\n\r\nThe system first uses the input task network to develop a Gantt chart using the [critical path method](https://en.wikipedia.org/wiki/Critical_path_method). For each task, the early start date and late finish date are computed. These dates correspond to the earliest a task may begin given the completion of prerequisite tasks and the latest that a task can possibly be completed without preventing the rest of the project from being completed in the minimum possible duration. Some tasks can be delayed for a certain amount of time without holding up the rest of the project while others can not. This amount of delay is called \"float\" and is represented with the '~' symbol in the Gantt chart output below. Tasks with zero float are considered critical tasks since they must be started and completed by specific days or the entire project completion will be delayed. \r\n\r\n![Project network](https://github.com/jrthom18/Project-Scheduling-System/blob/master/images/SampleGanttChart.PNG?raw=true)\r\n\r\nOnce a Gantt chart has been generated, the system can search for an optimized resource allocation to each task. To do this, the system implements the hill climber method. Each new candidate schedule is scored based on the efficiency ratings of the resources assigned to each task. The score function is designed to favor schedules that assign higher-rated resources to the longer critical tasks. A portion of the score function is shown here:\r\n\r\n     for day in range(0, len(scheduleDataStructure)):\r\n     # iterate through each day of the project Gantt chart\r\n        for task in project.nodes:\r\n            if scheduleDataStructure[day][project.nodes.index(task)] != []:\r\n                # for each task, assign a score based on the resources assigned\r\n                for worker in scheduleDataStructure[day][project.nodes.index(task)]:\r\n                    taskScore += worker.efficiencyRatings[task.idNo - 1]\r\n                if task.total_float > 0:\r\n                    taskScore /= task.total_float\r\n                elif task.total_float == 0:\r\n                    taskScore *= task.duration\r\n                dayScore += taskScore\r\n                taskScore = 0.0         # reset the task score before loop begins again\r\n        # add sum to total score\r\n        totalScore += dayScore\r\n        # reset the day score before advancing loop to next day in schedule\r\n        dayScore = 0.0   \r\n\r\n## Results\r\nThe hill climber method has a number of benefits. Most notably, it is relatively simple to implement and will often produce a good result even when the amount of time available to perform the optimization is limited. Although it may not yield the 'best' result that a more complex and costly algorithm would, it does not require a long run time that would be necessary to find an optimal schedule for a large task network. \r\n\r\nIn order to see how often the hill climber was finding a new optimal schedule, I decided to plot the number of optimizations made over a series of trials at each one-second time increment for the example presented above. The results are shown below. From the data, it is clear that the vast majority of optimizations were found in the first ten seconds of the hill climber's execution. \r\n\r\n![Optimizations made over time](https://github.com/jrthom18/Project-Scheduling-System/blob/master/images/HillClimberOptimizationsOverTime.png?raw=true)\r\n\r\nGiven these results, to test the efficiency of the hill climber method, I ran one hundred ten-second trials for the example presented above and collected data for the average number of schedules scored in ten seconds and the average score of the best schedule found after ten seconds. The data showed that, on average, 3071 schedules were analyzed every 10 seconds and the best score found was 332.8. The maximum possible score given the sample input was 356.5 and there were 2,176,782,336 possible unique assignments of resources to tasks (assuming every task was always assigned at least one person per day). This means that the hill climber was able to find a schedule that was over 93% as efficient as the ideal schedule but only had to analyze a tiny fraction (0.00014108%) of all the possible schedules to do so. ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}